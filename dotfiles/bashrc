#!/bin/bash
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples
if [ -f /tmp/.echo ]; then
	echo "Using: ~/.bashrc"
fi

# Setup $PATH ENV Settings
if [ -f "${HOME}/.bash_PATH" ]; then
  . "${HOME}/.bash_PATH"
fi

# remove duplicate path entries
export PATH=$(echo "$PATH" | awk -F: ' { for (i = 1; i <= NF; i++) arr[$i]; } END { for (i in arr) printf "%s:" , i; printf "\n"; } ')

# If not running interactively, don't do anything
[ -z "$PS1" ] && return

# Make remote variables local
#if [ -f "${HOME}/.ssh/variables" ]; then
#	. "${HOME}/.ssh/variables"
#fi

# keep track of SSH Connections
if [ -z "${LC_SSHConn}" ]; then
	export LC_SSHConn="${USER}@$(hostname -s)"
	export LC_SSHLVLS=0
else
	export LC_SSHConn="$(printf "${LC_SSHConn}\n${SSH_CONNECTION}")"
fi

LC_SSHLVLS="$(printf "${LC_SSHConn}"|grep -v '@'|wc -l|sed -e 's/^ *//')"

# Shells is interactive
OS=$(uname)
IsSU="$(ps a|grep -E "sudo|su -l"|grep -v "grep"|wc -l|sed -e s/[\ "$(printf "\t")"]//g)"
# don't put duplicate lines in the history. See bash(1) for more options
# ... or force ignoredups and ignorespace
HISTCONTROL=ignoredups:ignorespace

###### Saves terminal commands in history file in real time (for use with 'shopt -s histappend')
if [ ! -f $HOME/.bash_history ];then 
	touch $HOME/.bash_history
fi	

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=10000

# append to the history file, don't overwrite it
shopt -s histappend
# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
shopt -s mailwarn				# keep an eye on the mail file (access time)

# Less Setup
# make less more friendly for non-text input files, see lesspipe(1)
#[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# Put Generic Functions here
if [ -f "${HOME}/.bash_functions" ]; then
	. "${HOME}/.bash_functions"
fi

# autocomplete ssh commands
complete -W "$(echo `cat ~/.bash_history | egrep '^ssh ' | sort | uniq | sed 's/^ssh //'`;)" ssh

export	IsSSH=""
#if [[ $(who am i) =~ \([0-9\.]+\)$ ]]; then
if [[ $(who am i) =~ \(.*\)$ ]]; then
	IsSSH="SSH"
fi

# Support .bash_machine file
if [ -f "${HOME}/.bash_machine" ]; then
	. "${HOME}/.bash_machine"
fi
#	say -v Karen "Welcome back Joe"

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

color_prompt=yes
if [ -n "$force_color_prompt" ]; then
	if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
# We have color support; assume it's compliant with Ecma-48
# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
# a case would tend to support setf rather than setaf.)
		color_prompt=yes
	else
		color_prompt=
	fi
fi
if [ -f "${HOME}/.bash_colors" ]; then
  . "${HOME}/.bash_colors"
fi

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
	if [ -r ~/.dircolors ]; then
		eval "$(dircolors -b ~/.dircolors)"
	else
		eval "$(dircolors -b)"
	fi
fi

#echo "$IsSU - $SHLVL"
if [ "$IsSU" = "0" ]&&[ "${SHLVL}" = "1" ]; then
	neofetch
else
  if [ "$(ipmine)" = "$(ipext)" ]; then
    IPAddresses="$(fg_red "Ext/Lcl"):$(ipmine)"
  else
    IPAddresses="$(fg_red "Ext") :$(ipext) $(fg_red "Lcl"):$(ipmine)"
  fi
	  THISHOST="$(echo "${USER}@$(hostname -s)"| tr '[:upper:]' '[:lower:]')"
  	THISHOST="$(figlet -w 130 -k -f banner3-d -d "${FigletDir}" "${THISHOST}")"
  	if [ "${USER}" = "root" ]; then
      echo "$(fg_red "${THISHOST}" 2>/dev/null)"
			center_text "$(bg_red1 "$(printf " %.0s" {1..130})")"
  	else
      echo "$(fg_green3 "${THISHOST}" 2>/dev/null)"
			center_text "$(bg_green "$(printf " %.0s" {1..130})")"
  	fi
        if [ -f /tmp/.echo ]; then
                echo "Using: $(pwd)/.zshrc@4.1"
        fi
        IPAddresses=$(printf "${IPAddresses// / + }"|sed -e 's/+ + //'|sed -e 's/ + $//')
        printf "${IPAddresses}\n"
fi
# set variable identifying the chroot you work in (used in the prompt below)
#if [ -z "$debian_chroot" ] && [ -r /etc/debian_chroot ]; then
#  debian_chroot=$(cat /etc/debian_chroot)
#fi

if [ "$color_prompt" = yes ]; then
  PROMPT_COMMAND=__prompt_command 2>&1 # Func to gen PS1 after CMDs
  __prompt_command () {
	  local EXIT="$?"			 # This needs to be first
	  local SHVer=$(< ~/.bash_shver)

	  PS1=""
	  if [ $EXIT != 0 ]; then
      PWDERR="[$(VpN)][${Blue}\D{%m.%d} ${Yellow}\D{%T$}{NC}]${LBrown}=> ${NC}\w\n|${Red}${EXIT}${eNC}"
	  else
      PWDERR="[$(VpN)][${Blue}\D{%m.%d} ${Yellow}\D{%T}${NC}]${LBrown}=> ${NC}\w\n|${Green}OK${eNC}"
	  fi
	  if [ "${USER}" = "root" ]; then
		  [ "${OS}" = "Darwin" ] && set +o posix    
      USERINFO="${NC}|${Red}\u${NC}@${Cyan}\h"
		  PROMPT="${Red}#${NC} "
	  else
		  USERINFO="${NC}|${Green}\u${NC}@${Cyan}\h"
		  PROMPT="${Green}\$${NC} "
	  fi
	  PS1="${PWDERR}${USERINFO}${SEP2}${LBrown}SSH${SEP}${LBrown}${LC_SSHLVLS}${SEP2}${LBlue}SU${SEP}${LBlue}${IsSU:-0}${SEP2}${Magenta}SL${SEP}${Magenta}${SHLVL}${SEP2}${Yellow}Jbs${SEP}${Yellow}\j${SEP2}${Green}Hst${SEP}${Green}\!${SEP2}${LBlue}Fls${SEP}${LBlue}$(tfiles)${SEP}${LBlue}$(tsize)${SEP2}${Brown}Ver${NC}:${Brown}${SHVer}${SEP2}\n${PROMPT}$(tab "$(whoami)@$(hostname -s)")"
  }
fi
# Set command line to vi mode after ESC
set -o vi
# Update/Download any changes from git
if [ -z "$(git status --porcelain)" ] && [ -z "$(git diff --stat origin/master)" ]; then
	git reset --hard origin/master >/dev/null 2>&1
	git pull origin master 2>/dev/null
else
	echo "$(fg_red1 "Git:") You have items to '$(fg_red1 "git $(f_blink "add/commit/push")")'"
fi
#vncserver :1 -geometry 1024x768
#tab "$(whoami)@$(hostname -s)"
. ~/.bash_login
